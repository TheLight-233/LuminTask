<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

using System;
using System.Threading;
using System.Collections.Generic;
using System.Linq;

namespace LuminThread.TaskSource.Promise;

<#
for (int i = 2; i <= 15; i++)
{
    var typeParams = string.Join(", ", Enumerable.Range(1, i).Select(n => $"T{n}"));
    var tupleType = $"({typeParams})";
    var taskParams = string.Join(", ", Enumerable.Range(1, i).Select(n => $"LuminTask<T{n}> task{n}"));
    var createParams = string.Join(", ", Enumerable.Range(1, i).Select(n => $"task{n}"));
#>
public sealed unsafe class WhenAllPromise<<#= typeParams #>>
{
<# for (int j = 1; j <= i; j++) { #>
    T<#= j #> t<#= j #> = default;
<# } #>
    int completedCount;
    internal LuminTaskSourceCore<<#= tupleType #>>* core;

    public static WhenAllPromise<<#= typeParams #>> Create(<#= taskParams #>)
    {
        return new WhenAllPromise<<#= typeParams #>>(<#= createParams #>);
    }
    
    public WhenAllPromise(<#= taskParams #>)
    {
        core = LuminTaskSourceCore<<#= tupleType #>>.Create();
        
        this.completedCount = 0;
<# for (int j = 1; j <= i; j++) { #>
        {
            var awaiter = task<#= j #>.GetAwaiter();
            if (awaiter.IsCompleted)
            {
                TryInvokeContinuationT<#= j #>(this, awaiter);
            }
            else
            {
                awaiter.SourceOnCompleted(static state =>
                {
                    var t = (Tuple<WhenAllPromise<<#= typeParams #>>, LuminTaskAwaiter<T<#= j #>>>)state;
                    TryInvokeContinuationT<#= j #>(t.Item1, t.Item2);
                }, Tuple.Create(this, awaiter));
            }
        }
<# } #>
    }

<# for (int j = 1; j <= i; j++) { #>
    static void TryInvokeContinuationT<#= j #>(WhenAllPromise<<#= typeParams #>> self, in LuminTaskAwaiter<T<#= j #>> awaiter)
    {
        try
        {
            self.t<#= j #> = awaiter.GetResult();
        }
        catch (Exception ex)
        {
            LuminTaskSourceCore<<#= tupleType #>>.TrySetException(self.core, ex);
            LuminTaskSourceCore<<#= tupleType #>>.Dispose(self.core);
            return;
        }
                
        if (Interlocked.Increment(ref self.completedCount) == <#= i #>)
        {
            LuminTaskSourceCore<<#= tupleType #>>.TrySetResult(self.core, (self.t1<# for (int k = 2; k <= i; k++) { #>, self.t<#= k #><# } #>));
            LuminTaskSourceCore<<#= tupleType #>>.Dispose(self.core);
        }
    }

<# } #>
}

<# } #>

public sealed unsafe class WhenAllPromise<T>
{
    private T[] _results;
    private int _completedCount;
    private int _totalCount;
    internal LuminTaskSourceCore<T[]>* _core;

    public static WhenAllPromise<T> Create(params LuminTask<T>[] tasks)
    {
        return new WhenAllPromise<T>(tasks);
    }
    
    public static WhenAllPromise<T> Create(IEnumerable<LuminTask<T>> tasks)
    {
        return new WhenAllPromise<T>(tasks.ToArray());
    }
    
    public WhenAllPromise(LuminTask<T>[]? tasks)
    {
        if (tasks == null || tasks.Length == 0)
        {
            _results = Array.Empty<T>();
            _core = LuminTaskSourceCore<T[]>.Create();
            LuminTaskSourceCore<T[]>.TrySetResult(_core, _results);
            return;
        }

        _totalCount = tasks.Length;
        _results = new T[_totalCount];
        _core = LuminTaskSourceCore<T[]>.Create();
        _completedCount = 0;

        for (int i = 0; i < tasks.Length; i++)
        {
            var index = i;
            var awaiter = tasks[i].GetAwaiter();
            
            if (awaiter.IsCompleted)
            {
                TryInvokeContinuation(this, awaiter, index);
            }
            else
            {
                awaiter.SourceOnCompleted(static state =>
                {
                    var tuple = (Tuple<WhenAllPromise<T>, LuminTaskAwaiter<T>, int>)state;
                    TryInvokeContinuation(tuple.Item1, tuple.Item2, tuple.Item3);
                }, Tuple.Create(this, awaiter, index));
            }
        }
    }

    static void TryInvokeContinuation(WhenAllPromise<T> self, in LuminTaskAwaiter<T> awaiter, int index)
    {
        try
        {
            self._results[index] = awaiter.GetResult();
        }
        catch (Exception ex)
        {
            LuminTaskSourceCore<T[]>.TrySetException(self._core, ex);
            LuminTaskSourceCore<T[]>.Dispose(self._core);
            return;
        }
                
        if (Interlocked.Increment(ref self._completedCount) == self._totalCount)
        {
            LuminTaskSourceCore<T[]>.TrySetResult(self._core, self._results);
            LuminTaskSourceCore<T[]>.Dispose(self._core);
        }
    }
}

public sealed unsafe class WhenAllPromise
{
    private int _completedCount;
    private int _totalCount;
    internal LuminTaskSourceCore<bool>* _core;

    public static WhenAllPromise Create(params LuminTask[] tasks)
    {
        return new WhenAllPromise(tasks);
    }
    
    public static WhenAllPromise Create(IEnumerable<LuminTask> tasks)
    {
        return new WhenAllPromise(tasks.ToArray());
    }
    
    public WhenAllPromise(LuminTask[]? tasks)
    {
        if (tasks == null || tasks.Length == 0)
        {
            _core = LuminTaskSourceCore<bool>.Create();
            LuminTaskSourceCore<bool>.TrySetResult(_core, true);
            return;
        }

        _totalCount = tasks.Length;
        _core = LuminTaskSourceCore<bool>.Create();
        _completedCount = 0;

        for (int i = 0; i < tasks.Length; i++)
        {
            var awaiter = tasks[i].GetAwaiter();
            
            if (awaiter.IsCompleted)
            {
                TryInvokeContinuation(this, awaiter);
            }
            else
            {
                awaiter.SourceOnCompleted(static state =>
                {
                    var tuple = (Tuple<WhenAllPromise, LuminTaskAwaiter>)state;
                    TryInvokeContinuation(tuple.Item1, tuple.Item2);
                }, Tuple.Create(this, awaiter));
            }
        }
    }

    static void TryInvokeContinuation(WhenAllPromise self, in LuminTaskAwaiter awaiter)
    {
        try
        {
            awaiter.GetResult();
        }
        catch (Exception ex)
        {
            LuminTaskSourceCore<bool>.TrySetException(self._core, ex);
            LuminTaskSourceCore<bool>.Dispose(self._core);
            return;
        }
                
        if (Interlocked.Increment(ref self._completedCount) == self._totalCount)
        {
            LuminTaskSourceCore<bool>.TrySetResult(self._core, true);
            LuminTaskSourceCore<bool>.Dispose(self._core);
        }
    }
}