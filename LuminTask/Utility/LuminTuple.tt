<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
//     This code was generated by a T4 template.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace LuminThread.Utility
{
<#
    for(int i = 1; i <= 15; i++)
    {
        var typeParams = string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j}"));
        var fieldNames = string.Join(", ", Enumerable.Range(1, i).Select(j => $"item{j}"));
        var fieldTypes = string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j}"));
#>
    /// <summary>
    /// Represents a <#= i #>-element tuple value.
    /// </summary>
<#
        for(int j = 1; j <= i; j++)
        {
#>
    /// <typeparam name="T<#= j #>">The type of the <#= j #> element.</typeparam>
<#
        }
#>
    [Serializable]
    public struct LuminTuple<<#= typeParams #>>
    {
<#
        for(int j = 1; j <= i; j++)
        {
#>
        private readonly T<#= j #> m_Item<#= j #>;
<#
        }
#>

        /// <summary>
        /// Initializes a new instance of the <see cref="LuminTuple{<#= fieldTypes #>}"/> struct.
        /// </summary>
<#
        for(int j = 1; j <= i; j++)
        {
#>
        /// <param name="item<#= j #>">The value of the <#= j #> element.</param>
<#
        }
#>
        public LuminTuple(<#= string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j} item{j}")) #>)
        {
<#
        for(int j = 1; j <= i; j++)
        {
#>
            m_Item<#= j #> = item<#= j #>;
<#
        }
#>
        }

        /// <summary>
        /// Creates a new <#= i #>-element tuple.
        /// </summary>
<#
        for(int j = 1; j <= i; j++)
        {
#>
        /// <param name="item<#= j #>">The value of the <#= j #> element.</param>
<#
        }
#>
        /// <returns>A <#= i #>-element tuple.</returns>
        public static LuminTuple<<#= typeParams #>> Create(<#= string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j} item{j}")) #>)
        {
            return new LuminTuple<<#= typeParams #>>(<#= string.Join(", ", Enumerable.Range(1, i).Select(j => $"item{j}")) #>);
        }

<#
        for(int j = 1; j <= i; j++)
        {
#>
        /// <summary>
        /// Gets the value of the <#= j #> element.
        /// </summary>
        public T<#= j #> Item<#= j #> => m_Item<#= j #>;

<#
        }
#>
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="LuminTuple{<#= fieldTypes #>}"/> object is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>true if the current instance is equal to the specified object; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return obj is LuminTuple<<#= fieldTypes #>> other && Equals(other);
        }

        /// <summary>
        /// Returns a value that indicates whether the current <see cref="LuminTuple{<#= fieldTypes #>}"/> object is equal to a specified <see cref="LuminTuple{<#= fieldTypes #>}"/>.
        /// </summary>
        /// <param name="other">The object to compare with this instance.</param>
        /// <returns>true if the current instance is equal to the specified object; otherwise, false.</returns>
        public bool Equals(LuminTuple<<#= fieldTypes #>> other)
        {
            return EqualityComparer<T1>.Default.Equals(m_Item1, other.m_Item1)
<#
            for(int j = 2; j <= i; j++)
            {
#>
                && EqualityComparer<T<#= j #>>.Default.Equals(m_Item<#= j #>, other.m_Item<#= j #>)
<#
            }
#>
            ;
        }

        /// <summary>
        /// Returns the hash code for the current <see cref="LuminTuple{<#= fieldTypes #>}"/> object.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
<#
            for(int j = 1; j <= i; j++)
            {
#>
                hash = hash * 23 + (m_Item<#= j #>?.GetHashCode() ?? 0);
<#
            }
#>
                return hash;
            }
        }

        /// <summary>
        /// Returns a string that represents the value of this <see cref="LuminTuple{<#= fieldTypes #>}"/> instance.
        /// </summary>
        /// <returns>The string representation of this <see cref="LuminTuple{<#= fieldTypes #>}"/> object.</returns>
        public override string ToString()
        {
<#
        if(i == 1)
        {
#>
            return $"({Item1})";
<#
        }
        else
        {
#>
            return $"({Item1}<# for(int j = 2; j <= i; j++) { #>, {Item<#= j #>}<# } #>)";
<#
        }
#>
        }

        /// <summary>
        /// Deconstructs the current tuple.
        /// </summary>
        public void Deconstruct(<#= string.Join(", ", Enumerable.Range(1, i).Select(j => $"out T{j} item{j}")) #>)
        {
<#
        for(int j = 1; j <= i; j++)
        {
#>
            item<#= j #> = m_Item<#= j #>;
<#
        }
#>
        }

        public static bool operator ==(LuminTuple<<#= fieldTypes #>> left, LuminTuple<<#= fieldTypes #>> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(LuminTuple<<#= fieldTypes #>> left, LuminTuple<<#= fieldTypes #>> right)
        {
            return !(left == right);
        }
    }

<#
    }
#>

    /// <summary>
    /// Represents a 16-element tuple value with TRest as the 16th element.
    /// </summary>
<#
    for(int j = 1; j <= 15; j++)
    {
#>
    /// <typeparam name="T<#= j #>">The type of the <#= j #> element.</typeparam>
<#
    }
#>
    /// <typeparam name="TRest">The type of the rest element.</typeparam>
    [Serializable]
    public struct LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest>
    {
<#
    for(int j = 1; j <= 15; j++)
    {
#>
        private readonly T<#= j #> m_Item<#= j #>;
<#
    }
#>
        private readonly TRest m_Rest;

        /// <summary>
        /// Initializes a new instance of the <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/> struct.
        /// </summary>
<#
    for(int j = 1; j <= 15; j++)
    {
#>
        /// <param name="item<#= j #>">The value of the <#= j #> element.</param>
<#
    }
#>
        /// <param name="rest">The value of the rest element.</param>
        public LuminTuple(<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j} item{j}")) #>, TRest rest)
        {
<#
    for(int j = 1; j <= 15; j++)
    {
#>
            m_Item<#= j #> = item<#= j #>;
<#
    }
#>
            m_Rest = rest;
        }

        /// <summary>
        /// Creates a new 16-element tuple.
        /// </summary>
<#
    for(int j = 1; j <= 15; j++)
    {
#>
        /// <param name="item<#= j #>">The value of the <#= j #> element.</param>
<#
    }
#>
        /// <param name="rest">The value of the rest element.</param>
        /// <returns>A 16-element tuple.</returns>
        public static LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> Create(<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j} item{j}")) #>, TRest rest)
        {
            return new LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest>(<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"item{j}")) #>, rest);
        }

<#
    for(int j = 1; j <= 15; j++)
    {
#>
        /// <summary>
        /// Gets the value of the <#= j #> element.
        /// </summary>
        public T<#= j #> Item<#= j #> => m_Item<#= j #>;

<#
    }
#>
        /// <summary>
        /// Gets the value of the rest element.
        /// </summary>
        public TRest Rest => m_Rest;

        /// <summary>
        /// Returns a value that indicates whether the current <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/> object is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>true if the current instance is equal to the specified object; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            return obj is LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> other && Equals(other);
        }

        /// <summary>
        /// Returns a value that indicates whether the current <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/> object is equal to a specified <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/>.
        /// </summary>
        /// <param name="other">The object to compare with this instance.</param>
        /// <returns>true if the current instance is equal to the specified object; otherwise, false.</returns>
        public bool Equals(LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> other)
        {
            return EqualityComparer<T1>.Default.Equals(m_Item1, other.m_Item1)
<#
    for(int j = 2; j <= 15; j++)
    {
#>
                && EqualityComparer<T<#= j #>>.Default.Equals(m_Item<#= j #>, other.m_Item<#= j #>)
<#
    }
#>
                && EqualityComparer<TRest>.Default.Equals(m_Rest, other.m_Rest);
        }

        /// <summary>
        /// Returns the hash code for the current <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/> object.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
<#
    for(int j = 1; j <= 15; j++)
    {
#>
                hash = hash * 23 + (m_Item<#= j #>?.GetHashCode() ?? 0);
<#
    }
#>
                hash = hash * 23 + (m_Rest?.GetHashCode() ?? 0);
                return hash;
            }
        }

        /// <summary>
        /// Returns a string that represents the value of this <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/> instance.
        /// </summary>
        /// <returns>The string representation of this <see cref="LuminTuple{<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest}"/> object.</returns>
        public override string ToString()
        {
            return $"({Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7}, {Item8}, {Item9}, {Item10}, {Item11}, {Item12}, {Item13}, {Item14}, {Item15}, {Rest})";
        }

        /// <summary>
        /// Deconstructs the current tuple.
        /// </summary>
<#
    for(int j = 1; j <= 15; j++)
    {
#>
        
<#
    }
#>
        /// <param name="rest">The value of the rest element.</param>
        public void Deconstruct(<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"out T{j} item{j}")) #>, out TRest rest)
        {
<#
    for(int j = 1; j <= 15; j++)
    {
#>
            item<#= j #> = m_Item<#= j #>;
<#
    }
#>
            rest = m_Rest;
        }

        public static bool operator ==(LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> left, LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> left, LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> right)
        {
            return !(left == right);
        }
    }

    /// <summary>
    /// Provides static methods for creating LuminTuple objects.
    /// </summary>
    public static class LuminTuple
    {
<#
    for(int i = 1; i <= 15; i++)
    {
        var typeParams = string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j}"));
        var methodParams = string.Join(", ", Enumerable.Range(1, i).Select(j => $"T{j} item{j}"));
        var callParams = string.Join(", ", Enumerable.Range(1, i).Select(j => $"item{j}"));
#>
        /// <summary>
        /// Creates a new <#= i #>-element tuple.
        /// </summary>
<#
        for(int j = 1; j <= i; j++)
        {
#>
        /// <param name="item<#= j #>">The value of the <#= j #> element.</param>
<#
        }
#>
        /// <returns>A <#= i #>-element tuple.</returns>
        public static LuminTuple<<#= typeParams #>> Create<<#= typeParams #>>(<#= methodParams #>)
        {
            return new LuminTuple<<#= typeParams #>>(<#= callParams #>);
        }

<#
    }
#>
        /// <summary>
        /// Creates a new 16-element tuple.
        /// </summary>
<#
    for(int j = 1; j <= 15; j++)
    {
#>
        /// <param name="item<#= j #>">The value of the <#= j #> element.</param>
<#
    }
#>
        /// <param name="rest">The value of the rest element.</param>
        /// <returns>A 16-element tuple.</returns>
        public static LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest> Create<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest>(<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j} item{j}")) #>, TRest rest)
        {
            return new LuminTuple<<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"T{j}")) #>, TRest>(<#= string.Join(", ", Enumerable.Range(1, 15).Select(j => $"item{j}")) #>, rest);
        }
    }
}